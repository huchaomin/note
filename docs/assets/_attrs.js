import{r as i,o as r,c as d,f as n,a8 as e,g as o,v as t}from"./vendor.js";const h=e("h2",{id:"1-$attrs-\u7528\u6CD5\u7684\u6539\u53D8",class:"doc-heading"},"$attrs \u7528\u6CD5\u7684\u6539\u53D8",-1),p=e("h3",{id:"2-summary",class:"doc-heading"},"Summary",-1),u=e("ul",null,[e("li",null,"Make the attrs fallthrough behavior more consistent;"),e("li",null,"Make it easier to pass all extraneous attrs to child elements / components.")],-1),m=e("h3",{id:"3-motivation",class:"doc-heading"},"Motivation",-1),f=e("p",null,[t("In Vue 2.x, components have an implicit attrs fallthrough behavior. Any prop passed to a component, but is not declared as a prop by the component, is considered an \u201Cextraneous attribute\u201D. In 2.x, these extraneous attributes are exposed in "),e("code",{class:"doc-token"},"this.$attrs"),t(" and implicitly applied to the component\u2019s root node. This behavior can be disabled with "),e("code",{class:"doc-token"},"inheritAttrs: false"),t(", where the user expects to explicit control where the attrs should be applied.")],-1),g=e("p",null,"There are a number of inconsistencies and issues in the 2.x behavior:",-1),_=e("ul",null,[e("li",null,[e("p",null,[e("code",{class:"doc-token"},"inheritAttrs: false"),t(" does not affect "),e("code",{class:"doc-token"},"class"),t(" and "),e("code",{class:"doc-token"},"style"),t(".")])]),e("li",null,[e("p",null,[e("code",{class:"doc-token"},"class"),t(", "),e("code",{class:"doc-token"},"style"),t(", "),e("code",{class:"doc-token"},"v-on"),t(" listeners and custom directives are not included in "),e("code",{class:"doc-token"},"$attrs"),t(", making it cumbersome for a higher-order component (HOC) to properly pass everything down to a nested child component.")])]),e("li",null,[e("p",null,"Functional components have no implicit attrs fallthrough at all.")])],-1),b=e("p",null,"In 3.x, the need for \u201Cspreading extraneous attrs\u201D also becomes more prominent due to the ability for components to render multiple root nodes (fragments). This RFC seeks to address these problems.",-1),v=e("h3",{id:"4-detailed-design",class:"doc-heading"},"Detailed design",-1),k=e("code",{class:"doc-token"},"this.$attrs",-1),w=e("strong",null,"everything",-1),y=e("strong",null,[t("This includes "),e("code",{class:"doc-token"},"class"),t(", "),e("code",{class:"doc-token"},"style"),t(", "),e("code",{class:"doc-token"},"v-on"),t(" listeners (as "),e("code",{class:"doc-token"},"onXXX"),t(" props), and custom directives (as "),e("code",{class:"doc-token"},"onVnodeXXX"),t(" props)")],-1),x=e("ul",null,[e("li",null,[e("p",null,[e("code",{class:"doc-token"},".native"),t(" modifier for "),e("code",{class:"doc-token"},"v-on"),t(" will be removed.")])]),e("li",null,[e("p",null,[e("code",{class:"doc-token"},"this.$listeners"),t(" will be removed.")])])],-1),$=e("p",null,[t("When the component returns a single root node, "),e("code",{class:"doc-token"},"this.$attrs"),t(" will be implicitly merged into the root node\u2019s props. This is the same as 2.x, except it will now include all the props that were not previously in "),e("code",{class:"doc-token"},"this.$attrs"),t(", as discussed above.")],-1),A=e("p",null,[e("strong",null,[t("If the component receives extraneous attrs, but returns multiple root nodes (a fragment), an automatic merge cannot be performed. If the user did not perform an explicit spread (checked by access to "),e("code",{class:"doc-token"},"this.$attrs"),t(" during render), a runtime warning will be emitted. The component should either pick an element to apply the attrs to (via "),e("code",{class:"doc-token"},'v-bind="$attrs"'),t("), or explicitly suppress the warning with "),e("code",{class:"doc-token"},"inheritAttrs: false"),t(".")])],-1),C=e("h3",{id:"5-inheritattrs-false",class:"doc-heading"},[e("code",{class:"doc-token"},"inheritAttrs: false")],-1),T=e("p",null,[t("With "),e("code",{class:"doc-token"},"inheritAttrs: false"),t(", the component can either choose to intentionally ignore all extraneous attrs, or explicitly control where the attrs should be applied via "),e("code",{class:"doc-token"},'v-bind="$attrs"'),t(":")],-1),F=e("p",null,[t("In 2.x, this option does not affect "),e("code",{class:"doc-token"},"class"),t(" and "),e("code",{class:"doc-token"},"style"),t(" - they will be implicitly merged on root in all cases for stateful components - but in 3.0 this special case is removed: "),e("code",{class:"doc-token"},"class"),t(" and "),e("code",{class:"doc-token"},"style"),t(" will be part of "),e("code",{class:"doc-token"},"$attrs"),t(" just like everything else.")],-1),j=e("h3",{id:"6-merging-attrs-in-render-functions-mergeprops-",class:"doc-heading"},"Merging Attrs in Render Functions(mergeProps)",-1),P=e("p",null,"In manual render functions, it may seem convenient to just use a spread:",-1),X=e("p",null,[t("However, this will cause attrs to overwrite whatever existing props of the same name. For example, there the local "),e("code",{class:"doc-token"},"class"),t(" may be overwritten when we probably want to merge the classes instead. Vue provides a "),e("code",{class:"doc-token"},"mergeProps"),t(" helper that handles the merging of "),e("code",{class:"doc-token"},"class"),t(", "),e("code",{class:"doc-token"},"style"),t(" and "),e("code",{class:"doc-token"},"onXXX"),t(" listeners:")],-1),I=e("p",null,[t("This is also what "),e("code",{class:"doc-token"},"v-bind"),t(" uses internally.")],-1),M=e("h3",{id:"7-consistency-between-functional-and-stateful-components",class:"doc-heading"},"Consistency between Functional and Stateful Components",-1),R=e("h3",{id:"8-components-with-no-props-declaration",class:"doc-heading"},"Components with no Props Declaration",-1),V=e("h3",{id:"9-unresolved-questions",class:"doc-heading"},"Unresolved questions",-1),D=e("h4",{class:"doc-heading"},"Removing Unwanted Listeners",-1),N=e("p",null,[t("With flat VNode data and the removal of "),e("code",{class:"doc-token"},".native"),t(" modifier, all listeners are passed down to the child component as "),e("code",{class:"doc-token"},"onXXX"),t(" functions:")],-1),S=e("p",null,"compiles to:",-1),q=e("p",null,[t("When spreading "),e("code",{class:"doc-token"},"$attrs"),t(" with "),e("code",{class:"doc-token"},"v-bind"),t(", all parent listeners are applied to the target element as native DOM listeners. The problem is that these same listeners can also be triggered by custom events - in the above example, both a native click event and a custom one emitted by "),e("code",{class:"doc-token"},"this.$emit('click')"),t(" in the child will trigger the parent\u2019s "),e("code",{class:"doc-token"},"foo"),t(" handler. This may lead to unwanted behavior.")],-1),W=e("code",{class:"doc-token"},"$attrs",-1),B=e("p",null,[t("Event listeners for explicitly declared events will be removed from "),e("code",{class:"doc-token"},"$attrs"),t(" and can only be triggered by custom events emitted by the component via "),e("code",{class:"doc-token"},"this.$emit"),t(".")],-1),L={__name:"$attrs",setup(O){const c=[{id:"doc-title",title:"$attrs \u7528\u6CD5\u7684\u6539\u53D8"},{id:"1-$attrs-\u7528\u6CD5\u7684\u6539\u53D8",title:"1. $attrs \u7528\u6CD5\u7684\u6539\u53D8"},{id:"2-summary",title:"1.1. Summary",sub:!0},{id:"3-motivation",title:"1.2. Motivation",sub:!0},{id:"4-detailed-design",title:"1.3. Detailed design",sub:!0},{id:"5-inheritattrs-false",title:"1.4. inheritAttrs: false",sub:!0},{id:"6-merging-attrs-in-render-functions-mergeprops-",title:"1.5. Merging Attrs in Render Functions(mergeProps)",sub:!0},{id:"7-consistency-between-functional-and-stateful-components",title:"1.6. Consistency between Functional and Stateful Components",sub:!0},{id:"8-components-with-no-props-declaration",title:"1.7. Components with no Props Declaration",sub:!0},{id:"9-unresolved-questions",title:"1.8. Unresolved questions",sub:!0}];return(U,H)=>{const a=i("doc-link"),s=i("doc-code"),l=i("doc-page");return r(),d(l,{desc:"",toc:c},{default:n(()=>[h,e("p",null,[o(a,{to:"https://github.com/vuejs/rfcs/pull/92/files?diff=unified&w=1"},{default:n(()=>[t("\u82F1\u6587\u5B98\u65B9\u6587\u6863")]),_:1})]),p,u,m,f,g,_,b,v,e("p",null,[k,t(" now contains "),w,t(" passed to the component except those that are declared as props. "),y,t(". (This is based on flat props structure as proposed in "),o(a,{to:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0008-render-function-api-change.md#flat-vnode-props-format"},{default:n(()=>[t("Render Function API Change")]),_:1}),t("). As a result of this:")]),x,$,A,C,T,o(s,{code:`<div class="wrapper">
  <!-- apply attrs to an inner element instead of root -->
  <input v-bind="$attrs">
</div>
`,lang:"html"}),F,j,P,o(s,{code:`export default {
  props: { /* ... */ },
  inheritAttrs: false,
  render() {
    return h('div', { class: 'foo', ...this.$attrs })
  }
}
`,lang:"js"}),X,o(s,{code:`import { mergeProps } from 'vue'
export default {
  props: { /* ... */ },
  inheritAttrs: false,
  render() {
    return h('div', mergeProps({ class: 'foo' }, this.$attrs))
  }
}
`,lang:"js"}),I,M,e("p",null,[t("Functional components will now share the exact same behavior with Stateful components. The extraneous attrs is passed via the second context argument (as specified in "),o(a,{to:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0008-render-function-api-change.md#functional-component-signature"},{default:n(()=>[t("Render Function API Change")]),_:1}),t("):")]),o(s,{code:`const Func = (props, { attrs }) => {
  return h('div', mergeProps({ id: 'x' }, attrs), props.msg)
}
Func.props = { /* ... */ }
`,lang:"js"}),R,e("p",null,[t("Note that for components without props declaration (see "),o(a,{to:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0010-optional-props-declaration.md"},{default:n(()=>[t("Optional Props Declaration")]),_:1}),t("), there will be no implicit attrs handling of any kind, because everything passed in is considered a prop and there will be no \u201Cextraneous\u201D attrs. A component without props declaration (mostly functional components) is responsible for explicitly passing down necessary props. This can be easily done with object rest spread:")]),o(s,{code:`const Func = ({ msg, ...rest }) => {
  return h('div', mergeProps({ id: 'x' }, rest), [
    h('span', msg)
  ])
}
`,lang:"js"}),V,D,N,o(s,{code:`<foo @click="foo" @custom="bar" />
`,lang:"html"}),S,o(s,{code:`h(foo, {
  onClick: foo,
  onCustom: bar
})
`,lang:"js"}),q,e("p",null,[t("Props do not suffer from this problem because declared props are removed from "),W,t(". Therefore we should have a similar way to \u201Cdeclare\u201D emitted events from a component. There is currently "),o(a,{to:"https://github.com/vuejs/rfcs/pull/16"},{default:n(()=>[t("an open RFC for it")]),_:1}),t(" by @niko278.")]),B]),_:1})}}};export{L as default};
