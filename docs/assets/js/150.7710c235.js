(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{655:function(a,s,t){"use strict";t.r(s);var e=t(7),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"async、await-的使用场景是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async、await-的使用场景是什么"}},[a._v("#")]),a._v(" async、await 的使用场景是什么？")]),a._v(" "),t("p",[a._v("进阶一：假如有A、B、C三个异步请求，异步请求C依赖于异步请求A和B的结果（即A和B完成后再发起C），那么你会如何实现它？")]),a._v(" "),t("p",[a._v("Promise.all()；\n设置状态分别标记A和B，A、B完成后会去修改自己的完成标记，然后检查所有的状态标记，假如都是完成状态，然后去执行异步请求C。")]),a._v(" "),t("h2",{attrs:{id:"数字计算-请问在js中-输入表达式-0-1-0-2-的结果是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字计算-请问在js中-输入表达式-0-1-0-2-的结果是什么"}},[a._v("#")]),a._v(" 数字计算：请问在js中，输入表达式 0.1 + 0.2 的结果是什么？")]),a._v(" "),t("p",[a._v("0.30000000000000004（能回答出来不是0.3，而是0.3后有若干个0和一个数字即可）\n解决方案：math.js")]),a._v(" "),t("h2",{attrs:{id:"移动端开发的时候-一般怎么实现自适应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#移动端开发的时候-一般怎么实现自适应"}},[a._v("#")]),a._v(" 移动端开发的时候，一般怎么实现自适应？")]),a._v(" "),t("p",[a._v("rem\nvw和vh\n媒体查询（bootstrap）")]),a._v(" "),t("h2",{attrs:{id:"px、em、rem区别介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#px、em、rem区别介绍"}},[a._v("#")]),a._v(" px、em、rem区别介绍")]),a._v(" "),t("h2",{attrs:{id:"的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#的作用是什么"}},[a._v("#")]),a._v(" "),t("keep-alive"),a._v("的作用是什么")],1),a._v(" "),t("keep-alive"),a._v("包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。 大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用"),t("keep-alive"),a._v("进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染\n"),t("h2",{attrs:{id:"vue子组件调用父组件的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue子组件调用父组件的方法"}},[a._v("#")]),a._v(" Vue子组件调用父组件的方法")]),a._v(" "),t("p",[a._v("第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法")]),a._v(" "),t("p",[a._v("第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。")]),a._v(" "),t("h2",{attrs:{id:"localstorage和sessionstorage是什么-区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localstorage和sessionstorage是什么-区别是什么"}},[a._v("#")]),a._v(" localstorage和sessionstorage是什么?区别是什么?")]),a._v(" "),t("p",[a._v("localstorage和sessionstorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型对象")]),a._v(" "),t("p",[a._v("localstorage生命周期是永久的，这意味着除非用户在浏览器提供的UI上清除localstorage信息，否则这些信息将永远存在。")]),a._v(" "),t("p",[a._v("sessionstorage生命周期为当前窗口或标签，一旦窗口或标签被永久关闭了，那么所有通过sessionstorage存储的数据也将被清空。")]),a._v(" "),t("p",[a._v("不同浏览器无法共享localstorage或sessionstorage中的信息。相同浏览器的不同页面可以共享相同的localstorage（页面属于相同的域名和端口），但是不同页面或标签间无法共享sessionstorage。这里需要注意的是，页面及标签仅指顶级窗口，如果一个标签页包含多个iframe标签他们属于同源页面，那么他们之间是可以共享sessionstorage的。")]),a._v(" "),t("h2",{attrs:{id:"什么是unicode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是unicode"}},[a._v("#")]),a._v(" 什么是unicode")]),a._v(" "),t("h2",{attrs:{id:"v-show指令-v-if的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-show指令-v-if的区别"}},[a._v("#")]),a._v(" v-show指令，v-if的区别")]),a._v(" "),t("p",[a._v("条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值")]),a._v(" "),t("h2",{attrs:{id:"为什么避免v-if和v-for用在一起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么避免v-if和v-for用在一起"}},[a._v("#")]),a._v(" 为什么避免v-if和v-for用在一起？")]),a._v(" "),t("p",[a._v("当vue处理指令时，v-for比v-if具有更高的优先级，通过v-if移动到容器的元素，不会在重复遍历列表中的每个值，取而代之的是，我们只检查它一次，且不会v-if为否的时候运算v-for")]),a._v(" "),t("h2",{attrs:{id:"vue中有没有使用css预编译语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中有没有使用css预编译语言"}},[a._v("#")]),a._v(" vue中有没有使用css预编译语言")]),a._v(" "),t("h2",{attrs:{id:"vue的路由实现-hash模式-和-history模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的路由实现-hash模式-和-history模式"}},[a._v("#")]),a._v(" Vue的路由实现：hash模式 和 history模式")]),a._v(" "),t("p",[a._v("hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；\n特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。\nhash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。")]),a._v(" "),t("p",[a._v("history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。\nhistory 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”")]),a._v(" "),t("h2",{attrs:{id:"用flex布局实现一个父元素-里面三个子元素-子元素高度占100-子元素加起来宽度要把父元素撑满-但每个不一定相等"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用flex布局实现一个父元素-里面三个子元素-子元素高度占100-子元素加起来宽度要把父元素撑满-但每个不一定相等"}},[a._v("#")]),a._v(" 用flex布局实现一个父元素，里面三个子元素，子元素高度占100%,子元素加起来宽度要把父元素撑满，但每个不一定相等")]),a._v(" "),t("h2",{attrs:{id:"transform-translate-50px-100px"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transform-translate-50px-100px"}},[a._v("#")]),a._v(" transform: translate(50px,100px);")])],1)}),[],!1,null,null,null);s.default=r.exports}}]);