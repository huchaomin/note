(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{726:function(t,e,n){"use strict";n.r(e);var a=n(7),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const ThemeContext = React.createContext('light');      //需要传的值,‘light’为默认值\nclass App extends React.Component {\n  render() {\n    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n    // 无论多深，任何组件都能读取这个值。\n    return (\n      <ThemeContext.Provider value=\"dark\">      //实际的值‘dark’\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\n//中间件\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // 指定 contextType 读取当前的 theme context。\n  // React 会往上找到最近的 ThemeContext.Provider，然后使用它的值。\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n")])])]),n("h2",{attrs:{id:"使用-context-之前的考虑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-context-之前的考虑"}},[t._v("#")]),t._v(" 使用 Context 之前的考虑")]),t._v(" "),n("ol",[n("li",[t._v("请谨慎使用，因为这会使得组件的复用性变差。")]),t._v(" "),n("li",[t._v("只有底层的组件，需要用到顶层组件的数据，可以考虑组件组合（component composition）")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Page(props) {\n  const user = props.user;\n  const userLink = (\n    <Link href={user.permalink}>\n      <Avatar user={user} size={props.avatarSize} />\n    </Link>\n  );\n  return <PageLayout userLink={userLink} />;        //将底层组件自身传递下去\n}\n\n// 现在，我们有这样的组件：\n<Page user={user} avatarSize={avatarSize} />\n// ... 渲染出 ...\n<PageLayout userLink={...} />\n// ... 渲染出 ...\n<NavigationBar userLink={...} />\n// ... 渲染出 ...\n{props.userLink}\n")])])]),n("h2",{attrs:{id:"api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" API")]),t._v(" "),n("h5",{attrs:{id:"eact-createcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eact-createcontext"}},[t._v("#")]),t._v(" eact.createContext")]),t._v(" "),n("ol",[n("li",[t._v("创建一个 Context 对象。")]),t._v(" "),n("li",[t._v("当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身 =="),n("strong",[t._v("最近的")]),t._v("== 那个匹配的 Provider 中读取到当前的 context 值。")]),t._v(" "),n("li",[t._v("只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。")]),t._v(" "),n("li",[t._v("将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const MyContext = React.createContext(defaultValue);\n")])])]),n("h5",{attrs:{id:"context-provider"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-provider"}},[t._v("#")]),t._v(" Context.Provider")]),t._v(" "),n("ol",[n("li",[t._v("每个 Context 对象都会返回一个 Provider React 组件，它允许消费(子)组件订阅 context 的变化。")]),t._v(" "),n("li",[t._v("多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。")]),t._v(" "),n("li",[t._v("当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<MyContext.Provider value={/* 某个值 */}>\n")])])]),n("h5",{attrs:{id:"class-contexttype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#class-contexttype"}},[t._v("#")]),t._v(" Class.contextType")]),t._v(" "),n("ol",[n("li",[t._v("挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。")]),t._v(" "),n("li",[t._v("这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class MyClass extends React.Component {\n    //static contextType = MyContext;(public class fields 语法)[推荐]\n    componentDidMount() {\n        let value = this.context;\n    }\n    componentWillUnmount() {\n        let value = this.context;\n    }\n    render() {\n        let value = this.context;\n    }\n}\nMyClass.contextType = MyContext;\n")])])]),n("h5",{attrs:{id:"context-consumer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-consumer"}},[t._v("#")]),t._v(" Context.Consumer")]),t._v(" "),n("p",[t._v("消费MyContext组件的组件是一个函数式组件时使用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class ThemedButton extends React.Component {\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n//转换\nfunction ThemedButton() {\n    return (\n        <ThemeContext.Consumer>\n            {value => (\n                <Button theme={value} />\n            )}\n        </ThemeContext.Consumer>\n    )\n}\n")])])]),n("h5",{attrs:{id:"context-displayname"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-displayname"}},[t._v("#")]),t._v(" Context.displayName")]),t._v(" "),n("ol",[n("li",[t._v("类型为字符串")]),t._v(" "),n("li",[t._v("React DevTools 使用该字符串来确定 context 要显示的内容。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const MyContext = React.createContext(/* some value */);\nMyContext.displayName = \'MyDisplayName\';\n<MyContext.Provider> // "MyDisplayName.Provider" 在 DevTools 中\n<MyContext.Consumer> // "MyDisplayName.Consumer" 在 DevTools 中\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);