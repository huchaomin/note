(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{674:function(e,t,n){"use strict";n.r(t);var r=n(7),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"动态-context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态-context"}},[e._v("#")]),e._v(" 动态 Context")]),e._v(" "),n("h5",{attrs:{id:"theme-context-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#theme-context-js"}},[e._v("#")]),e._v(" theme-context.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export const themes = {\n  light: {\n    foreground: '#000000',\n    background: '#eeeeee',\n  },\n  dark: {\n    foreground: '#ffffff',\n    background: '#222222',\n  },\n};\n\nexport const ThemeContext = React.createContext(\n  themes.dark // 默认值\n);\n//输出一个Context组件\n")])])]),n("h5",{attrs:{id:"themed-button-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#themed-button-js"}},[e._v("#")]),e._v(" themed-button.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {ThemeContext} from './theme-context';\n\nclass ThemedButton extends React.Component {\n  render() {\n    let props = this.props;\n    let theme = this.context;\n    return (\n      <button\n        {...props}\n        style={{backgroundColor: theme.background}}\n      />\n    );\n  }\n}\nThemedButton.contextType = ThemeContext;\nexport default ThemedButton;\n//最底层消费Context的组件\n")])])]),n("h5",{attrs:{id:"app-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#app-js"}},[e._v("#")]),e._v(" app.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {ThemeContext, themes} from './theme-context';\nimport ThemedButton from './themed-button';\n\n// 一个使用 ThemedButton 的中间组件\nfunction Toolbar(props) {\n  return (\n    <ThemedButton onClick={props.changeTheme}>\n      Change Theme\n    </ThemedButton>\n  );\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      theme: themes.light,\n    };\n\n    this.toggleTheme = () => {\n      this.setState(state => ({\n        theme:\n          state.theme === themes.dark\n            ? themes.light\n            : themes.dark,\n      }));\n    };\n  }\n\n  render() {\n    // 在 ThemeProvider 内部的 ThemedButton 按钮组件使用 state 中的 theme 值，\n    // 而外部的组件使用默认的 theme 值\n    return (\n      <Page>\n        <ThemeContext.Provider value={this.state.theme}>\n          <Toolbar changeTheme={this.toggleTheme} />    //点击之后，Provider的值随之改变\n        </ThemeContext.Provider>\n        <Section>\n          <ThemedButton />      //点击没有反应\n        </Section>\n      </Page>\n    );\n  }\n}\n\nReactDOM.render(<App />, document.root);\n")])])]),n("blockquote",[n("p",[e._v("思路是把上层组件的事件一层一层传递到下层")])]),e._v(" "),n("h2",{attrs:{id:"在嵌套组件中更新-context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在嵌套组件中更新-context"}},[e._v("#")]),e._v(" 在嵌套组件中更新 Context")]),e._v(" "),n("h5",{attrs:{id:"theme-context-js-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#theme-context-js-2"}},[e._v("#")]),e._v(" theme-context.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export const ThemeContext = React.createContext({\n  theme: themes.dark,\n  toggleTheme: () => {},\n});\n//输出一个Context组件\n")])])]),n("h5",{attrs:{id:"theme-toggler-button-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#theme-toggler-button-js"}},[e._v("#")]),e._v(" theme-toggler-button.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {ThemeContext} from './theme-context';\nfunction ThemeTogglerButton() {\n  // Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数\n  return (\n    <ThemeContext.Consumer>\n      {({theme, toggleTheme}) => (\n        <button\n          onClick={toggleTheme}\n          style={{backgroundColor: theme.background}}>\n\n          Toggle Theme\n        </button>\n      )}\n    </ThemeContext.Consumer>\n  );\n}\nexport default ThemeTogglerButton;\n//最底层消费Context的组件\n")])])]),n("h5",{attrs:{id:"app-js-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#app-js-2"}},[e._v("#")]),e._v(" app.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {ThemeContext, themes} from './theme-context';\nimport ThemeTogglerButton from './theme-toggler-button';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.toggleTheme = () => {\n      this.setState(state => ({\n        theme:\n          state.theme === themes.dark\n            ? themes.light\n            : themes.dark,\n      }));\n    };\n\n    // State 也包含了更新函数，因此它会被传递进 context provider。\n    this.state = {\n      theme: themes.light,\n      toggleTheme: this.toggleTheme,\n    };\n  }\n\n  render() {\n    // 整个 state 都被传递进 provider\n    return (\n      <ThemeContext.Provider value={this.state}>\n        <Content />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\nfunction Content() {        //中间件没干扰了\n  return (\n    <div>\n      <ThemeTogglerButton />\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.root);\n")])])]),n("blockquote",[n("p",[e._v("只有上层组件和下层组件有监听事件（通过Context传递）")])]),e._v(" "),n("h2",{attrs:{id:"消费多个-context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消费多个-context"}},[e._v("#")]),e._v(" 消费多个 Context")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// Theme context，默认的 theme 是 “light” 值\nconst ThemeContext = React.createContext('light');\n\n// 用户登录 context\nconst UserContext = React.createContext({\n  name: 'Guest',\n});\n\nclass App extends React.Component {\n  render() {\n    const {signedInUser, theme} = this.props;\n\n    // 提供初始 context 值的 App 组件\n    return (\n      <ThemeContext.Provider value={theme}>\n        <UserContext.Provider value={signedInUser}>\n          <Layout />\n        </UserContext.Provider>\n      </ThemeContext.Provider>\n    );\n  }\n}\n\nfunction Layout() {\n  return (\n    <div>\n      <Sidebar />\n      <Content />\n    </div>\n  );\n}\n\n// 一个组件可能会消费多个 context\nfunction Content() {\n  return (\n    <ThemeContext.Consumer>\n      {theme => (\n        <UserContext.Consumer>\n          {user => (\n            <ProfilePage user={user} theme={theme} />\n          )}\n        </UserContext.Consumer>\n      )}\n    </ThemeContext.Consumer>\n  );\n}\n")])])]),n("h2",{attrs:{id:"注意重复渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意重复渲染"}},[e._v("#")]),e._v(" 注意重复渲染")]),e._v(" "),n("p",[e._v("当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 value 属性总是被赋值为==新的对象==：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class App extends React.Component {\n  render() {\n    return (\n      <Provider value={{something: 'something'}}>\n        <Toolbar />\n      </Provider>\n    );\n  }\n}\n")])])]),n("p",[e._v("为了防止这种情况，将 value 状态提升到父节点的 state 里：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: {something: 'something'},\n    };\n  }\n\n  render() {\n    return (\n      <Provider value={this.state.value}>\n        <Toolbar />\n      </Provider>\n    );\n  }\n}\n//此时只要value的值（引用类型），没有发生改变就不会重新渲染\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);