(window.webpackJsonp=window.webpackJsonp||[]).push([[174],{736:function(n,t,e){"use strict";e.r(t);var a=e(7),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。")]),n._v(" "),e("h2",{attrs:{id:"语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[n._v("#")]),n._v(" 语法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("ReactDOM.createPortal(child, container)\n")])])]),e("ul",[e("li",[n._v("child:任何可渲染的 React 子元素")]),n._v(" "),e("li",[n._v("container:一个 DOM 元素")])]),n._v(" "),e("h5",{attrs:{id:"例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[n._v("#")]),n._v(" 例")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("render() {\n  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。\n  // `domNode` 是一个可以在任何位置的有效 DOM 节点。\n  return ReactDOM.createPortal(\n    this.props.children,\n    domNode\n  );\n}\n")])])]),e("h5",{attrs:{id:"完整-model弹出框实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完整-model弹出框实例"}},[n._v("#")]),n._v(" 完整(model弹出框实例)")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 在 DOM 中有两个容器是兄弟级 （siblings）\nconst appRoot = document.getElementById('app-root');\nconst modalRoot = document.getElementById('modal-root');\n\nclass Modal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.el = document.createElement('div');\n  }\n\n  componentDidMount() {\n    // 在 Modal 的所有子元素被挂载后，\n    // 这个 portal 元素会被嵌入到 DOM 树中，\n    // 这意味着子元素将被挂载到一个分离的 DOM 节点中。\n    // 如果要求子组件在挂载时可以立刻接入 DOM 树，\n    // 例如衡量一个 DOM 节点，\n    // 或者在后代节点中使用 ‘autoFocus’，\n    // 则需添加 state 到 Modal 中，\n    // 仅当 Modal 被插入 DOM 树中才能渲染子元素。\n    modalRoot.appendChild(this.el);\n  }\n\n  componentWillUnmount() {\n    modalRoot.removeChild(this.el);\n  }\n\n  render() {\n    return ReactDOM.createPortal(\n      this.props.children,\n      this.el,\n    );\n  }\n}\n\nclass Parent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {clicks: 0};\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // 当子元素里的按钮被点击时，\n    // 这个将会被触发更新父元素的 state，\n    // 即使这个按钮在 DOM 中不是直接关联的后代\n    this.setState(state => ({\n      clicks: state.clicks + 1\n    }));\n  }\n\n  render() {\n    return (\n      <div onClick={this.handleClick}>\n        <p>Number of clicks: {this.state.clicks}</p>\n        <p>\n          Open up the browser DevTools\n          to observe that the button\n          is not a child of the div\n          with the onClick handler.\n        </p>\n        <Modal>\n          <Child />\n        </Modal>\n      </div>\n    );\n  }\n}\n\nfunction Child() {\n  // 这个按钮的点击事件会冒泡到父元素\n  // 因为这里没有定义 'onClick' 属性\n  return (\n    <div className=\"modal\">\n      <button>Click</button>\n    </div>\n  );\n}\n\nReactDOM.render(<Parent />, appRoot);\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);