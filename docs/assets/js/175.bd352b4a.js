(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{681:function(e,r,n){"use strict";n.r(r);var a=n(7),t=Object(a.a)({},(function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"目的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目的"}},[e._v("#")]),e._v(" 目的")]),e._v(" "),n("ol",[n("li",[e._v("Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。")]),e._v(" "),n("li",[e._v("目的是识别出应用中渲染较慢的部分")])]),e._v(" "),n("blockquote",[n("p",[e._v("Profiling 增加了额外的开支，所以它在生产构建中会被禁用。")])]),e._v(" "),n("h2",{attrs:{id:"用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),n("h5",{attrs:{id:"需要id和onrender-组件树中的组件-提交-更新的时候被react调用的回调函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#需要id和onrender-组件树中的组件-提交-更新的时候被react调用的回调函数"}},[e._v("#")]),e._v(" 需要id和onRender(组件树中的组件“提交”更新的时候被React调用的回调函数)")]),e._v(" "),n("p",[e._v("分析 Navigation 组件和它的子代")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('render(\n  <App>\n    <Profiler id="Navigation" onRender={callback}>\n      <Navigation {...props} />\n    </Profiler>\n    <Main {...props} />\n  </App>\n);\n')])])]),n("p",[e._v("多个 Profiler")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('render(\n  <App>\n    <Profiler id="Navigation" onRender={callback}>\n      <Navigation {...props} />\n    </Profiler>\n    <Profiler id="Main" onRender={callback}>\n      <Main {...props} />\n    </Profiler>\n  </App>\n);\n')])])]),n("p",[e._v("嵌套使用 Profiler")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('render(\n  <App>\n    <Profiler id="Panel" onRender={callback}>\n      <Panel {...props}>\n        <Profiler id="Content" onRender={callback}>\n          <Content {...props} />\n        </Profiler>\n        <Profiler id="PreviewPane" onRender={callback}>\n          <PreviewPane {...props} />\n        </Profiler>\n      </Panel>\n    </Profiler>\n  </App>\n);\n')])])]),n("h2",{attrs:{id:"onrender-回调"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#onrender-回调"}},[e._v("#")]),e._v(" onRender 回调")]),e._v(" "),n("p",[e._v("React 会在 profile 包含的组件树中任何组件 “提交” 一个更新的时候调用这个函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function onRenderCallback(\n  id, // 发生提交的 Profiler 树的 “id”\n  phase, // "mount" （如果组件树刚加载） 或者 "update" （如果它重渲染了）之一\n  actualDuration, // 本次更新 committed 花费的渲染时间\n  baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间\n  startTime, // 本次更新中 React 开始渲染的时间\n  commitTime, // 本次更新中 React committed 的时间\n  interactions // 属于本次更新的 interactions 的集合\n) {\n  // 合计或记录渲染时间。。。\n}\n')])])]),n("ol",[n("li",[e._v("id: string - 发生提交的 Profiler 树的 id。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。")]),e._v(" "),n("li",[e._v('phase: "mount" | "update" - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。')]),e._v(" "),n("li",[e._v("actualDuration: number - 本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 React.memo，useMemo，shouldComponentUpdate）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。")]),e._v(" "),n("li",[e._v("baseDuration: number - 在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。")]),e._v(" "),n("li",[e._v("startTime: number - 本次更新中 React 开始渲染的时间戳。")]),e._v(" "),n("li",[e._v("commitTime: number - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。")]),e._v(" "),n("li",[e._v("interactions: Set - “interactions” 的集合用来追踪已经列出的更新。（例如当 render 或者 setState 被调用时）。")])])])}),[],!1,null,null,null);r.default=t.exports}}]);