(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{686:function(t,a,e){"use strict";e.r(a);var l=e(7),n=Object(l.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"根节点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根节点"}},[t._v("#")]),t._v(" 根节点")]),t._v(" "),e("h5",{attrs:{id:"不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同"}},[t._v("#")]),t._v(" 不同")]),t._v(" "),e("p",[t._v("当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。")]),t._v(" "),e("ul",[e("li",[t._v("当拆卸一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmount() 方法。")]),t._v(" "),e("li",[t._v("当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 componentWillMount() 方法，紧接着 componentDidMount() 方法。所有跟之前的树所关联的 state 也会被销毁。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//React 会销毁 Counter 组件并且重新装载一个新的组件。\n<div>\n  <Counter />\n</div>\n\n<span>\n  <Counter />\n</span>\n")])])]),e("h5",{attrs:{id:"相同的dom元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同的dom元素"}},[t._v("#")]),t._v(" 相同的dom元素")]),t._v(" "),e("p",[t._v("React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//改变className\n<div className=\"before\" title=\"stuff\" />\n<div className=\"after\" title=\"stuff\" />\n\n//改变color\n<div style={{color: 'red', fontWeight: 'bold'}} />\n<div style={{color: 'green', fontWeight: 'bold'}} />\n")])])]),e("p",[t._v("在处理完当前节点之后，React 继续对子节点进行递归。")]),t._v(" "),e("h5",{attrs:{id:"相同的组件元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同的组件元素"}},[t._v("#")]),t._v(" 相同的组件元素")]),t._v(" "),e("ol",[e("li",[t._v("当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。")]),t._v(" "),e("li",[t._v("React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。")]),t._v(" "),e("li",[t._v("调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。")])]),t._v(" "),e("h2",{attrs:{id:"对子节点进行递归"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对子节点进行递归"}},[t._v("#")]),t._v(" 对子节点进行递归")]),t._v(" "),e("p",[t._v("在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。")]),t._v(" "),e("h5",{attrs:{id:"在子元素列表末尾新增元素时-更变开销比较小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在子元素列表末尾新增元素时-更变开销比较小"}},[t._v("#")]),t._v(" 在子元素列表末尾新增元素时，更变开销比较小")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n\n<ul>\n  <li>first</li>\n  <li>second</li>\n  <li>third</li>\n</ul>\n")])])]),e("h5",{attrs:{id:"在列表头部插入会很影响性能-那么更变开销会比较大。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在列表头部插入会很影响性能-那么更变开销会比较大。"}},[t._v("#")]),t._v(" 在列表头部插入会很影响性能，那么更变开销会比较大。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n")])])]),e("p",[t._v("React 会针对每个子元素 mutate 而不是保持相同的 <li>Duke</li> 和 <li>Villanova</li> 子树完成。这种情况下的低效可能会带来性能问题。")]),t._v(" "),e("h5",{attrs:{id:"key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key"}},[t._v("#")]),t._v(" key")]),t._v(" "),e("p",[t._v("为了解决以上问题,React 支持 key 属性")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<ul>\n  <li key="2015">Duke</li>\n  <li key="2016">Villanova</li>\n</ul>\n\n<ul>\n  <li key="2014">Connecticut</li>\n  <li key="2015">Duke</li>\n  <li key="2016">Villanova</li>\n</ul>\n')])])]),e("p",[t._v("现在 React 知道只有带着 '2014' key 的元素是新元素，带着 '2015' 以及 '2016' key 的元素仅仅移动了。")]),t._v(" "),e("blockquote",[e("p",[t._v("key 不需要全局唯一，但在列表中需要保持唯一"),e("br"),t._v("\n谨慎使用元素在数组中的下标作为 key")])])])}),[],!1,null,null,null);a.default=n.exports}}]);