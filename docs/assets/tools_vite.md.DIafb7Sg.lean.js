import{M as s,J as i,Q as t,D as e}from"./chunks/framework.xgaWqU_i.js";const k=JSON.parse('{"title":"使用vite构建自己的前端应用","description":"","frontmatter":{},"headers":[],"relativePath":"tools/vite.md","filePath":"tools/vite.md","lastUpdated":1727661788000}'),l={name:"tools/vite.md"};function n(d,a,h,o,r,p){return e(),i("div",null,a[0]||(a[0]=[t(`<h1 id="使用vite构建自己的前端应用" tabindex="-1">使用vite构建自己的前端应用 <a class="header-anchor" href="#使用vite构建自己的前端应用" aria-label="Permalink to &quot;使用vite构建自己的前端应用&quot;">​</a></h1><h2 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h2><h3 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-label="Permalink to &quot;JSON&quot;">​</a></h3><p>JSON 可以被直接导入 —— 同样支持具名导入</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入整个对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> json </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./example.json&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对一个根字段使用具名导入 —— 有效帮助 treeshaking！</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { field } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./example2.json&#39;</span></span></code></pre></div><h3 id="动态导入" tabindex="-1">动态导入 <a class="header-anchor" href="#动态导入" aria-label="Permalink to &quot;动态导入&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量仅代表一层深的文件名。如果 file 是 foo/bar，导入将会失败</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`./dir/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.js\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="环境变量和模式" tabindex="-1">环境变量和模式 <a class="header-anchor" href="#环境变量和模式" aria-label="Permalink to &quot;环境变量和模式&quot;">​</a></h2><h3 id="production" tabindex="-1">&#39;production&#39; <a class="header-anchor" href="#production" aria-label="Permalink to &quot;&#39;production&#39;&quot;">​</a></h3><p>应用运行的模式，可以通过 <code>--mode &lt;xxx&gt;</code> 指定，然后加载对应的 <code>.env.xxx</code> 文件 默认情况下, <code>dev</code> 命令 运行在 <code>development</code> 模式，而 <code>build</code> 命令则运行在 <code>production</code> 模式</p><h3 id="node-env" tabindex="-1">NODE_ENV <a class="header-anchor" href="#node-env" aria-label="Permalink to &quot;NODE_ENV&quot;">​</a></h3><p>与 <code>MODE</code> 的没有丝毫关系，是两个不同的概念 会影响 <code>PROD</code> 和 <code>DEV</code> 的行为</p><table tabindex="0"><thead><tr><th>Command</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>NODE_ENV=production</td><td>true</td><td>false</td></tr><tr><td>NODE_ENV=development</td><td>false</td><td>true</td></tr><tr><td>NODE_ENV=other</td><td>false</td><td>false</td></tr></tbody></table><p>可以在命令行中设置，也可以在env文件中设置</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">development</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vite</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">提示</p><p>命令中使用 <code>NODE_ENV=...</code> 的主要好处是，它允许 Vite 提前检测到该值, 该值的重要性最高，不需要等待读取 <code>env</code> 文件之后才拿到该值</p></div><h2 id="ssr" tabindex="-1">ssr <a class="header-anchor" href="#ssr" aria-label="Permalink to &quot;ssr&quot;">​</a></h2><h3 id="import-meta-url" tabindex="-1">import.meta.url <a class="header-anchor" href="#import-meta-url" aria-label="Permalink to &quot;import.meta.url&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">无法在 SSR 中使用</p><p>因为 import.meta.url 在浏览器和 Node.js 中有不同的语义。服务端的产物也无法预先确定客户端主机 URL。</p></div><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://github.com/antfu-collective/vitesse" target="_blank" rel="noreferrer">vitesse</a></li><li>unplugin-vue-router 和 vite-plugin-vue-layouts 可以不用自己写路由</li><li>vite-plugin-webfont-dl 自动处理字体</li></ul>`,21)]))}const u=s(l,[["render",n]]);export{k as __pageData,u as default};
