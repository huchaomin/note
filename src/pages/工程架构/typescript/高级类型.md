---
title: 高级类型
---

## 交叉类型

交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，就像扩展一样。

```ts
function extend<T, U>(first: T, second: U): T & U {
  let result = <T & U>{};
  for (let id in first) {
    (<any>result)[id] = (<any>first)[id];
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      (<any>result)[id] = (<any>second)[id];
    }
  }
  return result; // 返回的是两种类型的集合
}
```

## 联合类型

联合类型与交叉类型很相似，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。

```ts
function padLeft(value: string, padding: string | number) {
  // padding 为 string number 中的一种
}
```

如果一个值是联合类型，我们只能访问此联合类型的所有类型里共**有的成员**。

```ts
interface Bird {
  fly();
  layEggs();
}
interface Fish {
  swim();
  layEggs();
}

function getSmallPet(): Fish | Bird {
  // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
```

## 可以为null的类型

- 默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型
- `--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`
  你可以使用联合类型明确的包含它们

  ```ts
  let sn: string | null = "bar";
  sn = null; // 可以
  ```

使用了 `--strictNullChecks`，可选参数会被自动地加上 `| undefined` :

```ts
function f(x: number, y?: number) {
  return x + (y || 0);
}
f(1, 2);
f(1);
f(1, undefined);
f(1, null); // error, 'null' is not assignable to 'number | undefined'
```

可选属性也会有同样的处理：

```ts
class C {
  a: number;
  b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'
```

## 区分类型

```ts
function isFish(pet: Fish | Bird): pet is Fish { // 区分类型
  return (<Fish>pet).swim !== undefined;
}
```

## 字符串字面量类型

字符串字面量类型允许你指定字符串必须的固定值
在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。

```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
  animate(dx: number, dy: number, easing: Easing) {
    if (easing === "ease-in") {
      // ...
    }
    else if (easing === "ease-out") {
    }
    else if (easing === "ease-in-out") {
    }
    else {
      // error! should not pass null or undefined.
    }
  }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
```

字符串字面量类型还可以用于区分函数重载：

```ts
function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ... more overloads ...
function createElement(tagName: string): Element {
  // ... code goes here ...
}
```

## 数字字面量类型

```ts
function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {
  // ...
}
```

## this类型

this类型表示的是某个包含类或接口的子类型

```ts
class BasicCalculator {
  public constructor(protected value: number = 0) { }
  public currentValue(): number {
    return this.value;
  }
  public add(operand: number): this { // this类型
    this.value += operand;
    return this;
  }
  public multiply(operand: number): this {
    this.value *= operand;
    return this;
  }
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();
```

## 索引类型

javascript

```js
function pluck(o, names) {
  return names.map(n => o[n]);
}
```

typescript

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}

interface Person {
  name: string;
  age: number;
}
let person: Person = {
  name: 'Jarid',
  age: 35
};
let strings: string[] = pluck(person, ['name']); // ok, string[]
```

`keyof T`， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合

```ts
let personProps: keyof Person; // 'name' | 'age'
```

`T[K]`， 索引访问操作符

```ts
interface Map<T> {
  [key: string]: T;
}
let keys: keyof Map<number>; // string
let value: Map<number>['foo']; // number
```

## 映射类型

```ts
