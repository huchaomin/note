(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{730:function(n,t,e){"use strict";e.r(t);var a=e(7),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[n._v("#")]),n._v(" 定义")]),n._v(" "),e("p",[n._v("高阶组件是参数为组件，返回值为新组件的函数。"),e("br"),n._v("\n组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。")]),n._v(" "),e("h2",{attrs:{id:"例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[n._v("#")]),n._v(" 例")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n);\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 此函数接收一个组件...\nfunction withSubscription(WrappedComponent, selectData) {\n  // ...并返回另一个组件...\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ...负责订阅相关的操作...\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      // 请注意，我们可能还会传递其他属性\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n")])])]),e("h2",{attrs:{id:"不要改变原始组件。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不要改变原始组件。"}},[n._v("#")]),n._v(" 不要改变原始组件。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  };\n  // 返回原始的 input 组件，暗示它已经被修改。\n  return InputComponent;\n}\n\n// 每次调用 logProps 时，增强组件都会有 log 输出。\nconst EnhancedComponent = logProps(InputComponent);\n")])])]),e("h5",{attrs:{id:"不好的点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不好的点"}},[n._v("#")]),n._v(" 不好的点")]),n._v(" "),e("ol",[e("li",[n._v("输入组件被改变")]),n._v(" "),e("li",[n._v("如果你再用另一个同样会修改 componentWillReceiveProps 的 HOC 增强它，那么前面的 HOC 就会失效")]),n._v(" "),e("li",[n._v("这个 HOC 也无法应用于没有生命周期的函数组件")])]),n._v(" "),e("h5",{attrs:{id:"改正"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改正"}},[n._v("#")]),n._v(" 改正")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // 将 input 组件包装在容器中，而不对其进行修改。Good!\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n")])])]),e("h2",{attrs:{id:"约定-将不相关的-props-传递给被包裹的组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#约定-将不相关的-props-传递给被包裹的组件"}},[n._v("#")]),n._v(" 约定：将不相关的 props 传递给被包裹的组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("render() {\n  // 过滤掉非此 HOC 额外的 props，且不要进行透传\n  const { extraProp, ...passThroughProps } = this.props;\n\n  // 将 props 注入到被包装的组件中。\n  // 通常为 state 的值或者实例方法。\n  const injectedProp = someStateOrInstanceMethod;\n\n  // 将 props 传递给被包装组件\n  return (\n    <WrappedComponent\n      injectedProp={injectedProp}\n      {...passThroughProps}\n    />\n  );\n}\n//这种约定保证了 HOC 的灵活性以及可复用性\n")])])]),e("h2",{attrs:{id:"约定-最大化可组合性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#约定-最大化可组合性"}},[n._v("#")]),n._v(" 约定：最大化可组合性")]),n._v(" "),e("p",[n._v("略")]),n._v(" "),e("h2",{attrs:{id:"注意"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[n._v("#")]),n._v(" 注意")]),n._v(" "),e("ol",[e("li",[n._v("HOC 不会修改传入的组件，也不会使用继承来复制其行为")]),n._v(" "),e("li",[n._v("HOC 是纯函数，没有副作用。")]),n._v(" "),e("li",[n._v("HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。")]),n._v(" "),e("li",[n._v("不要在 render 方法中使用 HOC")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("render() {\n  // 每次调用 render 函数都会创建一个新的 EnhancedComponent\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\n  return <EnhancedComponent />;\n}\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[n._v("务必复制静态方法")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 定义静态函数\nWrappedComponent.staticMethod = function() {/*...*/}\n// 现在使用 HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 增强组件没有 staticMethod\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n")])])]),e("p",[n._v("应该")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // 必须准确知道应该拷贝哪些方法 :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n")])])]),e("p",[n._v("或者可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n")])])]),e("p",[n._v("除了导出组件，另一个可行的方案是再额外导出这个静态方法。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 使用这种方式代替...\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ...单独导出该方法...\nexport { someFunction };\n\n// ...并在要使用的组件中，import 它们\nimport MyComponent, { someFunction } from './MyComponent.js';\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);